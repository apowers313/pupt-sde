<Prompt
  name="sde-refactor"
  title="Refactor Code"
  description="Systematic code refactoring with behavioral equivalence verification, risk assessment, and before/after comparison"
  version="1.0.0"
  tags={["sde", "refactoring", "maintenance", "code-quality", "behavior-preservation"]}
  noRole
  noFormat
  noConstraints
  noSuccessCriteria
  noGuardrails
>

<Ask.Editor
  name="code"
  label="Code to refactor"
  description="Paste the code that needs refactoring. Include surrounding context (imports, class definitions) for accurate analysis."
  required
  silent
/>

<Ask.Select name="primaryGoal" label="Primary refactoring goal" default="readability" silent options={[
  { value: "readability", label: "Readability and Maintainability" },
  { value: "performance", label: "Performance Optimization" },
  { value: "modularity", label: "Modularity and Testability" },
  { value: "smells", label: "Code Smell Elimination" },
  { value: "solid", label: "SOLID Principles Alignment" }
]} />

<Ask.MultiSelect
  name="focusAreas"
  label="Additional focus areas (optional)"
  description="Select specific areas to emphasize during refactoring"
  silent
  options={[
    { value: "naming", label: "Naming improvements" },
    { value: "extraction", label: "Method/function extraction" },
    { value: "duplication", label: "Duplication elimination" },
    { value: "complexity", label: "Complexity reduction" },
    { value: "patterns", label: "Design pattern application" },
    { value: "error-handling", label: "Error handling improvements" },
    { value: "type-safety", label: "Type safety enhancements" },
    { value: "dead-code", label: "Dead code removal" }
  ]}
/>

<Ask.Text
  name="language"
  label="Programming language (optional)"
  description="Leave blank for auto-detection from code syntax"
  placeholder="e.g., TypeScript, Python, Java, Go, Rust"
  silent
/>

<Ask.Confirm
  name="includeTests"
  label="Include characterization tests for behavior verification?"
  description="Generate tests that capture current behavior to verify refactoring preserves it"
  default={true}
  silent
/>

<Role
  preset="engineer"
  experience="senior"
  expertise={["refactoring", "clean code", "design patterns", "testing", "static analysis"]}
  traits={["methodical", "detail-oriented", "pragmatic", "risk-averse"]}
  domain="code quality and maintainability"
>
  <Specialization
    areas={[
      "Martin Fowler refactoring catalog",
      "SOLID principles",
      "code smell identification and classification",
      "behavior-preserving transformations",
      "characterization testing",
      "incremental safe refactoring",
      "Michael Feathers legacy code techniques (seams, sprout, wrap)",
      "incremental migration strategies (Strangler Fig, Branch by Abstraction)"
    ]}
    level="expert"
  />
</Role>

<Objective
  primary="Refactor the provided code to improve quality while rigorously preserving all existing behavior through verified, incremental transformations"
  secondary={[
    "Identify and categorize code smells using standard taxonomy",
    "Apply named refactoring techniques from the established catalog",
    "Verify behavioral equivalence at each transformation step",
    "Assess and document refactoring risks with mitigation strategies",
    "Provide measurable before/after comparison with concrete metrics"
  ]}
  metrics={[
    "Cyclomatic complexity reduction percentage",
    "Maximum method/function length reduction",
    "Code duplication elimination percentage",
    "Number of code smells resolved",
    "Public interface preservation (zero changes for pure refactoring)"
  ]}
/>

<Task
  verb="Refactor"
  subject="the provided code"
  objective="to improve internal quality while rigorously preserving all observable behavior"
  scope="comprehensive"
  complexity="complex"
>
  Focus on {primaryGoal} as the primary refactoring goal. Apply proven refactoring techniques from
  Martin Fowler's catalog, ensuring every transformation is safe, incremental, and verifiable.

  The cardinal rule of refactoring: the code must behave identically before and after every
  transformation. Behavioral equivalence is not optional -- it is the defining constraint that
  separates refactoring from rewriting. Each step must be small enough that correctness can be
  verified by inspection or testing.
</Task>

<Context type="data" label="Code to Refactor" priority="critical" preserveFormatting>
{code}
</Context>

  <Context type="domain" label="Language Context" priority="important">
    Programming language: {language}
    Apply language-specific refactoring patterns, idioms, and conventions for {language}.
    Use language-appropriate tooling references when suggesting verification approaches.
  </Context>

<Context type="domain" label="Refactoring Goal" priority="important">
  Primary goal: {primaryGoal}

  <If when={primaryGoal === "readability"}>
    Prioritize naming improvements, method extraction, guard clauses, and reducing cognitive
    complexity. The refactored code should read like well-written prose describing its intent.
  </If>
  <If when={primaryGoal === "performance"}>
    Prioritize algorithmic improvements, unnecessary allocation removal, and data structure
    optimization. Only suggest performance refactorings backed by complexity analysis, not
    micro-optimizations. Behavior preservation is still paramount.
  </If>
  <If when={primaryGoal === "modularity"}>
    Prioritize extracting cohesive modules, reducing coupling, introducing dependency injection,
    and improving testability. Each extracted unit should have a single, clear responsibility.
  </If>
  <If when={primaryGoal === "smells"}>
    Systematically work through the code smell taxonomy. Address the most severe smells first,
    applying the canonical refactoring technique for each smell category.
  </If>
  <If when={primaryGoal === "solid"}>
    Evaluate the code against each SOLID principle and apply targeted refactorings to improve
    compliance. Prioritize Single Responsibility and Dependency Inversion as highest impact.
  </If>

      Additional focus areas: {focusAreas}
</Context>

<Context type="reference" source="Martin Fowler's Refactoring Catalog" priority="helpful" truncate>
  The refactoring catalog provides proven, named techniques for code improvement. Use standard
  terminology when reporting which techniques are applied:

  **Composing Methods:**
  - Extract Method/Function: Break long methods into smaller, focused ones
  - Inline Method: Replace a method call with the method body when indirection is unhelpful
  - Replace Temp with Query: Extract an expression into a method to improve clarity

  **Simplifying Conditionals:**
  - Decompose Conditional: Replace complex conditionals with named helper methods
  - Replace Nested Conditional with Guard Clauses: Flatten deep nesting
  - Consolidate Conditional Expression: Combine related condition checks
  - Replace Conditional with Polymorphism: Eliminate type-checking conditionals

  **Moving Features:**
  - Extract Class: Separate responsibilities into distinct classes
  - Move Method/Field: Relocate features to where they belong
  - Introduce Parameter Object: Group related parameters

  **Organizing Data:**
  - Replace Magic Number with Named Constant
  - Encapsulate Field: Add accessors instead of direct field access
  - Replace Data Value with Object: Wrap primitives with domain types

  **Simplifying Method Calls:**
  - Rename Method/Variable: Use intention-revealing names
  - Preserve Whole Object: Pass object instead of extracted values

  **Encapsulation:**
  - Encapsulate Variable: Replace direct access with getter/setter
  - Encapsulate Collection: Return copies instead of exposing internal collections
  - Encapsulate Record: Wrap data records with accessor methods
  - Hide Delegate: Remove unnecessary chaining through intermediaries

  **Dealing with Generalization:**
  - Pull Up Method/Field: Move shared behavior to parent
  - Extract Interface: Decouple from concrete implementations
  - Replace Subclass with Delegate: Favor composition over inheritance
</Context>

<Context type="reference" source="Incremental Migration Strategies" priority="helpful" truncate>
  When refactoring scope exceeds a single pass or touches architectural boundaries, consider
  these proven incremental strategies instead of big-bang restructuring:

  **Strangler Fig Pattern** (Fowler, 2004): Build new implementations alongside old ones behind
  a facade/proxy. Route requests incrementally to the new implementation. Retire the old system
  once all routes are migrated. Benefits: continuous delivery, low risk per increment.

  **Branch by Abstraction**: Introduce an abstraction layer over the code to be replaced.
  Migrate consumers to use the abstraction. Swap the implementation underneath. Remove the
  old implementation. Benefits: no feature branches needed, gradual transition.

  **Parallel Change (Expand and Contract)**: Add the new implementation alongside the old one.
  Migrate consumers from old to new. Remove the old implementation once all consumers have
  migrated. Benefits: backward compatibility throughout, rollback at any point.

  **Sprout and Wrap Techniques** (Feathers): Sprout -- extract new logic into separate testable
  methods and call from legacy code. Wrap -- rename the existing method, create a new method
  with the original name that wraps the old one. Both enable introducing testability into
  legacy code with minimal risk.
</Context>

<Context type="reference" source="Code Smell Taxonomy" priority="helpful" truncate>
  Use this taxonomy when categorizing identified code smells:

  **Bloaters** (code that grows excessively):
  Long Method, Large Class, Primitive Obsession, Long Parameter List, Data Clumps

  **Object-Orientation Abusers** (misapplied OO patterns):
  Switch Statements, Temporary Field, Refused Bequest, Alternative Classes with Different Interfaces

  **Change Preventers** (code resisting modification):
  Divergent Change, Shotgun Surgery, Parallel Inheritance Hierarchies

  **Dispensables** (unnecessary code):
  Comments (masking bad code), Duplicate Code, Dead Code, Speculative Generality, Lazy Class

  **Couplers** (excessive coupling between components):
  Feature Envy, Inappropriate Intimacy, Message Chains, Middle Man
</Context>

<Steps style="structured" verify selfCritique numbered showReasoning>
  <Step number={1}>
    **Assess refactorability**: Determine whether the code is a candidate for incremental
    refactoring or requires a rewrite. Evaluate these factors systematically:
    (a) Scope of problems -- are issues localized (favors refactoring) or systemic/architectural (favors rewrite)?
    (b) Test coverage -- adequate for safe changes, or absent/minimal?
    (c) Team familiarity -- is the code understood, or is it opaque legacy code?
    (d) Change frequency -- is this code actively modified (high ROI for refactoring) or stable and rarely touched (leave it alone)?
    (e) Business continuity -- can development continue during refactoring, or is a migration period needed?
    If incremental refactoring is viable, proceed. If the code needs larger structural changes,
    recommend an incremental migration strategy (Strangler Fig, Branch by Abstraction, or
    Parallel Change) rather than a big-bang rewrite. For code that works and is rarely changed,
    recommend leaving it alone -- the risk of refactoring exceeds the benefit.
  </Step>
  <Step number={2}>
    **Identify code smells and their interactions**: Systematically scan for smells using the
    taxonomy -- Bloaters, OO Abusers, Change Preventers, Dispensables, and Couplers. For each
    smell found, note: the smell name, specific location (line numbers or code excerpt), severity
    (Critical, High, Medium, Low), and impact on the stated refactoring goal. Additionally,
    identify smell co-occurrences -- smells that interact and amplify each other (e.g., a Long
    Method that also contains Feature Envy and Data Clumps). Co-occurring smells often need to
    be addressed together rather than individually.
  </Step>
  <Step number={3}>
    **Detect language-specific anti-patterns**: Identify patterns that violate the conventions
    and idioms of the programming language. Consider type system features, standard library
    usage, and community best practices specific to the language.
  </Step>
  <Step number={4}>
    **Assess test coverage and safety net**: Before refactoring, evaluate what safety nets exist.
    If tests are present, note their coverage level. If tests are absent or inadequate, recommend
    writing characterization tests first using Feathers' approach: capture actual current behavior
    as the baseline, not what the code "should" do. For code without tests, identify seams --
    places where behavior can be altered without changing the code (object seams via subclassing,
    link seams, preprocessing seams) -- to make the code testable. Consider the Sprout technique
    (extract new logic into separate testable methods) or the Wrap technique (rename and wrap
    existing methods) to introduce testability incrementally.
  </Step>
  <Step number={5}>
    **Catalog the public interface**: Before any transformation, explicitly document the public
    API surface -- function signatures, return types, side effects, error conditions, and
    observable state mutations. This serves as the behavioral contract that must not change.
  </Step>
  <Step number={6}>
    **Select refactoring techniques**: For each identified smell, choose the appropriate named
    refactoring technique from the catalog. Justify each choice by explaining how it addresses
    the smell and contributes to the primary goal. When smell co-occurrences are identified,
    plan techniques that address the interacting smells together. When a design pattern would
    emerge naturally from the refactoring (e.g., Replace Conditional with Polymorphism leading
    to Strategy pattern), note the pattern but apply it only if the smells concretely motivate
    it -- patterns should be evolved toward, not imposed upfront (Kerievsky's "Refactoring to
    Patterns" principle).
  </Step>
  <Step number={7}>
    **Plan the refactoring sequence**: Order transformations to minimize risk. Apply safe,
    mechanical refactorings first (renames, extract method) before structural changes (extract
    class, replace conditional with polymorphism). Each step in the sequence must produce
    compilable, runnable code. Consider using scratch refactoring (Feathers) -- making
    exploratory changes to understand the code, then reverting and starting properly with
    tests -- when the code's structure is unclear.
  </Step>
  <Step number={8}>
    **Apply refactorings incrementally**: Execute each transformation with clear rationale.
    For each step, identify exactly what changed and why. The refactored code should be
    complete and ready to use. Each step should be small enough that it could be a single
    micro-commit -- this enables easy rollback if any step introduces problems.
  </Step>
  <Step number={9}>
    **Verify behavioral equivalence**: This is the most critical step. For each transformation,
    verify that the refactored code preserves the original behavior by checking:
    (a) Public interface signatures remain identical (same inputs, same outputs, same errors).
    (b) Side effects are preserved (same state mutations, same I/O operations, same ordering).
    (c) Edge case behavior is unchanged (null/empty inputs, boundary values, error paths).
    (d) Invariants are maintained (preconditions, postconditions, class invariants).
    Document any behavioral nuance where verification requires careful attention.
  </Step>
  <Step number={10}>
    **Measure improvements**: Calculate concrete metrics comparing before and after code --
    cyclomatic complexity, maximum method length, duplication count, coupling (inter-module
    dependencies), cohesion (LCOM), number of code smells remaining, and any goal-specific
    metrics. Verify that no metric has degraded -- research (Hamdi et al., 2021) shows that
    refactoring can inadvertently worsen cohesion metrics if not monitored.
  </Step>
  <Step number={11}>
    **Assess risks**: For each transformation, evaluate: probability of introducing a defect,
    blast radius if a defect occurs, and mitigation strategy. Identify areas where additional
    testing is recommended before accepting the refactoring.
  </Step>
</Steps>

<Format type="markdown" template={`
## Summary

[2-3 sentence overview: what was refactored, which techniques were applied, and the most significant improvement achieved]

## Refactorability Assessment

**Verdict:** [REFACTOR / PHASED REFACTOR / RECOMMEND REWRITE]
**Rationale:** [Brief justification for the approach]

## Code Smells Identified

### Critical
- **[Smell Name]**: [Description] | \`line X-Y\` | [Impact on goal]

### High
- **[Smell Name]**: [Description] | \`line X-Y\` | [Impact on goal]

### Medium
- **[Smell Name]**: [Description] | \`line X-Y\` | [Impact on goal]

### Low
- **[Smell Name]**: [Description] | \`line X-Y\` | [Impact on goal]

## Public Interface Contract

**Functions/Methods:**
- \`functionName(params) -> returnType\`: [Brief description of observable behavior]

**Side Effects:** [List any state mutations, I/O operations, or external interactions]
**Error Conditions:** [List error/exception cases and their triggers]

## Refactoring Plan

### Techniques Applied
1. **[Catalog Technique Name]** -- [Which smell it addresses] -- [Expected benefit]
2. **[Catalog Technique Name]** -- [Which smell it addresses] -- [Expected benefit]

### Transformation Sequence
1. [Step description] -- Risk: [LOW/MEDIUM/HIGH]
2. [Step description] -- Risk: [LOW/MEDIUM/HIGH]
3. [...]

## Refactored Code

\`\`\`[language]
[Complete refactored implementation with inline comments explaining key changes]
\`\`\`

## Behavioral Equivalence Verification

### Interface Preservation
| Aspect | Before | After | Preserved? |
|--------|--------|-------|------------|
| Function signature(s) | [signature] | [signature] | [YES/NO] |
| Return type(s) | [type] | [type] | [YES/NO] |
| Side effects | [list] | [list] | [YES/NO] |
| Error conditions | [list] | [list] | [YES/NO] |

### Critical Behavioral Notes
- [Any subtle behavior that required careful preservation, e.g., evaluation order, null handling]

### Verification Scenarios
- [Input scenario]: Expected output [X] -- Verified: [YES/NEEDS TESTING]
- [Edge case]: Expected output [X] -- Verified: [YES/NEEDS TESTING]

## Before/After Comparison

### Metrics
| Metric | Before | After | Change |
|--------|--------|-------|--------|
| Cyclomatic Complexity | X | Y | [direction] Z% |
| Max Method Length | X lines | Y lines | [direction] Z lines |
| Code Duplication | X instances | Y instances | [direction] Z |
| Code Smells | X | Y | [direction] Z |
| Coupling (dependencies) | X | Y | [direction] Z |
| Number of Methods/Functions | X | Y | [direction] Z |

### Key Improvements
- [Specific improvement with quantified impact]
- [Specific improvement with quantified impact]

## Risk Assessment

### Overall Risk Level: [LOW / MEDIUM / HIGH]

### Risk Matrix
| Transformation | Risk | Probability | Blast Radius | Mitigation |
|---------------|------|-------------|--------------|------------|
| [Technique] | [L/M/H] | [description] | [description] | [strategy] |

### Breaking Changes
- [Should be NONE for pure refactoring. If any exist, explain why and document migration path.]

## Safety Net Assessment

**Existing test coverage:** [Describe what tests exist for this code, if any are visible or mentioned]
**Recommended safety nets before refactoring:**
- [Characterization tests needed? Seams identified for introducing tests?]
- [Type system verification available?]
- [Static analysis tools applicable?]

${includeTests ? `
## Characterization Tests

Tests that capture the current behavior to verify the refactoring preserves it. Run these
against the original code first to establish the baseline, then against the refactored code
to confirm equivalence.

\`\`\`[language]
[Comprehensive test suite covering:
 - Normal operation paths
 - Edge cases (empty inputs, boundary values, null/undefined)
 - Error conditions
 - Side effects verification
 - Return value equivalence]
\`\`\`
` : `
## Testing Recommendations

[Key test scenarios to verify behavior preservation]
- [Normal path scenarios]
- [Edge cases to verify]
- [Error conditions to confirm]
`}

## Migration Notes

[If the refactoring affects call sites or requires coordination:]
- [Step-by-step adoption guide]
- [Backward compatibility notes]
- [If no migration needed: "Drop-in replacement -- no call site changes required."]
`} strict validate />

<Constraints presets={["acknowledge-uncertainty", "no-hallucination"]}>
  <Constraint type="must" category="accuracy">
    Preserve all existing observable behavior -- the refactored code MUST be functionally
    identical to the original for all inputs, including edge cases and error conditions
  </Constraint>
  <Constraint type="must" category="accuracy">
    Explicitly document the public interface contract before refactoring and verify it is
    unchanged after refactoring
  </Constraint>
  <Constraint type="must" category="accuracy">
    Identify the programming language correctly (from the language input if provided,
    otherwise infer from code syntax and state the inference)
  </Constraint>
  <Constraint type="must" category="content">
    Name each refactoring technique using standard catalog terminology from Fowler's catalog
    or widely recognized equivalents
  </Constraint>
  <Constraint type="must" category="content">
    Provide specific line numbers or code excerpts when identifying code smells and issues
  </Constraint>
  <Constraint type="must" category="accuracy">
    Calculate before/after metrics accurately based on measurable properties of the actual code
  </Constraint>
  <Constraint type="should" category="content">
    Order refactorings from highest-impact lowest-risk to lowest-impact highest-risk
  </Constraint>
  <Constraint type="should" category="content">
    Explain the reasoning behind each refactoring choice, connecting it to the identified smell
  </Constraint>
  <Constraint type="should" category="accuracy">
    Ensure each step in the refactoring sequence produces compilable, runnable code
  </Constraint>
  <Constraint type="must-not" category="scope" positive="Focus only on structural improvements to existing code">
    Add new features, fix bugs, or change external behavior during refactoring
  </Constraint>
  <Constraint type="must-not" category="accuracy" positive="Understand the code's purpose before suggesting changes">
    Suggest refactorings that might alter behavior without explicitly flagging the risk
  </Constraint>
  <Constraint type="should-not" category="scope" positive="Apply design patterns only when they solve a concrete problem">
    Apply design patterns speculatively without a clear, identified code smell motivating them
  </Constraint>
  <Constraint type="must" category="accuracy">
    Verify that no quality metric (complexity, coupling, cohesion) has degraded after
    refactoring -- research shows refactoring can inadvertently worsen metrics like LCOM
    (Lack of Cohesion in Methods) if not monitored; flag any metric that worsened and explain why
  </Constraint>
  <Constraint type="should" category="content">
    When code lacks tests, recommend characterization tests or approval tests as the first step
    before applying structural refactorings -- identify seams (Feathers) where tests can be
    introduced with minimal code changes
  </Constraint>
</Constraints>

<Guardrails preset="standard"
  prohibit={[
    "Changing observable behavior or fixing bugs during refactoring (bugs should be noted but fixed separately)",
    "Recommending full rewrites when incremental refactoring can achieve the goal safely",
    "Applying design patterns for their own sake without a concrete smell motivating them",
    "Suggesting refactorings that change the public API without explicit justification",
    "Ignoring side effects or error handling when verifying behavioral equivalence"
  ]}
  require={[
    "Document the public interface contract before and after refactoring",
    "Verify that refactored code maintains the exact same observable behavior",
    "Explain why each refactoring improves the code relative to the stated goal",
    "Assess and document the risk level of each proposed transformation",
    "Provide a clear refactoring sequence where each step maintains compilability",
    "When refactoring scope is large, recommend incremental migration strategies (Strangler Fig, Branch by Abstraction, Parallel Change) over big-bang restructuring",
    "Verify that no quality metric has degraded after refactoring; flag any worsened metrics with explanation"
  ]}
/>

<EdgeCases preset="standard">
  <When condition="code contains language-specific idioms or patterns"
    then="Recognize and preserve idiomatic patterns; suggest improvements that align with language conventions rather than fighting them" />
  <When condition="code is already well-written with minimal smells"
    then="Acknowledge the code quality honestly; suggest only minor polish improvements or state that the code needs minimal refactoring; do not manufacture issues" />
  <When condition="code has complex business logic that is unclear without domain context"
    then="Note the business logic complexity; avoid refactoring logic you do not fully understand; request clarification on business rules and suggest conservative structural refactorings that do not touch the core logic" />
  <When condition="multiple refactoring approaches are equally valid"
    then="Present the top 2-3 options with trade-offs (risk, effort, benefit) and recommend the most pragmatic approach for the stated goal" />
  <When condition="code appears to be generated or auto-formatted by a tool"
    then="Identify the generation pattern; adapt recommendations to work within the constraints of the code generation tool; note that regeneration may overwrite manual refactorings" />
  <When condition="refactoring would require changes to code outside the provided snippet"
    then="Note the external dependencies; confine refactoring to the provided code; document what additional changes would be needed if the broader codebase were available" />
  <When condition="code contains performance-critical hot paths"
    then="Flag the performance-sensitive sections; verify that refactorings do not introduce performance regressions (e.g., additional allocations in tight loops); recommend benchmarking before and after" />
  <When condition="code has concurrency or thread-safety concerns"
    then="Preserve all synchronization, locking, and ordering guarantees; flag any refactoring that might alter timing or visibility semantics; recommend thread-safety testing" />
  <When condition="code mixes multiple responsibilities but they share mutable state"
    then="Plan extraction carefully to avoid introducing shared state bugs; consider whether the state coupling is essential or accidental before splitting" />
  <When condition="code has multiple co-occurring smells that interact"
    then="Address interacting smells together rather than individually; for example, a Long Method with Feature Envy and Data Clumps requires extracting the data structure first, then moving the method; sequencing matters when smells amplify each other" />
  <When condition="code is part of a larger legacy system without tests"
    then="Apply Feathers' Legacy Code Change Algorithm: identify seams, break dependencies minimally, write characterization tests for the specific area being refactored, then proceed with safe transformations; recommend Sprout or Wrap techniques for introducing new testable code alongside untested legacy code" />
  <When condition="refactoring scope exceeds a single session or PR"
    then="Recommend an incremental migration strategy: Strangler Fig (facade routing between old and new), Branch by Abstraction (introduce abstraction layer, swap implementation), or Parallel Change (expand with new code, migrate consumers, contract by removing old code); each increment should be independently deployable" />
</EdgeCases>

<Fallbacks preset="standard">
  <Fallback when="unable to determine programming language"
    then="analyze the code syntax to infer the most likely language, state the inference with confidence level, and apply language-agnostic refactoring principles" />
  <Fallback when="code has severe quality issues that may exceed refactoring scope"
    then="clearly distinguish between what can be refactored incrementally and what requires rewriting; recommend a phased approach: stabilize with tests first, then refactor in stages, then consider rewrite for the most deeply flawed sections" />
  <Fallback when="unclear whether certain code is dead or used via dynamic dispatch/reflection"
    then="flag the code as potentially dead but recommend verification through runtime analysis, code coverage tools, or codebase-wide search before removal" />
  <Fallback when="code has no tests and refactoring risks are unclear"
    then="recommend writing characterization tests that capture current behavior before performing any refactoring; provide example tests as a starting point; identify seams (Feathers) where tests can be introduced with minimal code changes; suggest Sprout or Wrap techniques to introduce testable code alongside legacy code" />
  <Fallback when="refactoring scope is too large for a single pass"
    then="recommend an incremental migration strategy: Strangler Fig pattern (facade routing between old and new implementations), Branch by Abstraction (introduce abstraction layer, swap implementation underneath), or Parallel Change (add new code alongside old, migrate consumers, then remove old code); each increment should be independently deployable and verifiable" />
</Fallbacks>

<WhenUncertain action="acknowledge">
  If uncertain about whether a transformation preserves behavior, state the uncertainty
  explicitly and recommend one of: (a) adding characterization tests before refactoring,
  (b) performing the refactoring in a smaller, more verifiable step, or (c) leaving that
  section unchanged and documenting it as a candidate for future refactoring with tests.

  If uncertain about the code's intent or business rules, describe the ambiguity, suggest
  the most conservative refactoring that does not depend on the uncertain interpretation,
  and flag the area for human review.
</WhenUncertain>

<Examples>
  <Example>
    <ExampleInput>{`
function processOrder(o) {
  if (o.items.length > 0) {
    let t = 0;
    for (let i = 0; i &lt; o.items.length; i++) {
      t = t + o.items[i].price * o.items[i].qty;
    }
    if (o.customer.type == "VIP") {
      t = t * 0.9;
    }
    if (t > 100) {
      o.shipping = 0;
    } else {
      o.shipping = 10;
    }
    return t + o.shipping;
  }
  return 0;
}
`}    </ExampleInput>
    <ExampleOutput>{`
## Summary

Refactored \`processOrder\` to improve readability by extracting cohesive responsibilities into named functions, replacing magic numbers with named constants, and improving variable names. Applied Extract Method, Rename Variable, Replace Magic Number with Named Constant, and Decompose Conditional.

## Refactorability Assessment

**Verdict:** REFACTOR
**Rationale:** Single function with clear structure and manageable complexity. Incremental refactoring will achieve significant readability improvement with low risk.

## Code Smells Identified

### Medium
- **Poor naming (Bloater)**: Variables \`o\`, \`t\`, \`i\` are single-letter and non-descriptive | \`line 1, 3, 4\` | Severely reduces readability
- **Magic numbers (Bloater)**: 0.9, 100, 0, 10 encode business rules without context | \`lines 7, 9, 10, 12\` | Business rules are hidden in arithmetic
- **Long Method (Bloater)**: 16 lines handling subtotal, discount, and shipping | Entire function | Violates Single Responsibility
- **Nested conditional (OO Abuser)**: Multiple sequential if-blocks at different abstraction levels | \`lines 7-13\` | Obscures the high-level algorithm

## Public Interface Contract

**Functions/Methods:**
- \`processOrder(o) -> number\`: Calculates total cost (subtotal with discount + shipping) for an order object
  - Returns 0 if order has no items
  - Mutates \`o.shipping\` as a side effect

**Side Effects:** Sets \`o.shipping\` to 0 or 10 based on discounted total
**Error Conditions:** None explicitly handled; assumes \`o.items\`, \`o.customer.type\` exist

## Refactoring Plan

### Techniques Applied
1. **Rename Variable** -- Poor naming smell -- Makes code self-documenting
2. **Replace Magic Number with Named Constant** -- Magic numbers smell -- Makes business rules explicit and configurable
3. **Extract Method** -- Long Method smell -- Separates subtotal, discount, and shipping into focused functions
4. **Decompose Conditional** -- Nested conditional smell -- Simplifies shipping logic to a single expression

### Transformation Sequence
1. Rename \`o\` to \`order\`, \`t\` to \`subtotal\`, \`i\` to index variable (eliminated) -- Risk: LOW
2. Extract constants for VIP_DISCOUNT_RATE, FREE_SHIPPING_THRESHOLD, STANDARD_SHIPPING_COST -- Risk: LOW
3. Extract \`calculateSubtotal(items)\` function -- Risk: LOW
4. Extract \`applyCustomerDiscount(subtotal, customer)\` function -- Risk: LOW
5. Extract \`calculateShipping(total)\` function, replace nested if/else -- Risk: LOW
6. Invert top-level guard clause for empty items -- Risk: LOW

## Refactored Code

\`\`\`javascript
const VIP_DISCOUNT_RATE = 0.10;
const FREE_SHIPPING_THRESHOLD = 100;
const STANDARD_SHIPPING_COST = 10;

function processOrder(order) {
  if (order.items.length === 0) {
    return 0;
  }

  const subtotal = calculateSubtotal(order.items);
  const discountedTotal = applyCustomerDiscount(subtotal, order.customer);
  const shippingCost = calculateShipping(discountedTotal);

  // Preserve original side effect: sets shipping on the order object
  order.shipping = shippingCost;

  return discountedTotal + shippingCost;
}

function calculateSubtotal(items) {
  return items.reduce((total, item) => total + item.price * item.qty, 0);
}

function applyCustomerDiscount(subtotal, customer) {
  if (customer.type === "VIP") {
    return subtotal * (1 - VIP_DISCOUNT_RATE);
  }
  return subtotal;
}

function calculateShipping(total) {
  return total > FREE_SHIPPING_THRESHOLD ? 0 : STANDARD_SHIPPING_COST;
}
\`\`\`

## Behavioral Equivalence Verification

### Interface Preservation
| Aspect | Before | After | Preserved? |
|--------|--------|-------|------------|
| Function signature | \`processOrder(o)\` | \`processOrder(order)\` | YES (rename only) |
| Return type | number | number | YES |
| Side effects | sets \`o.shipping\` | sets \`order.shipping\` | YES |
| Error conditions | none | none | YES |

### Critical Behavioral Notes
- The original uses \`==\` for VIP comparison (loose equality); preserved as \`===\` which is safe since both sides are strings. If \`customer.type\` could be a non-string, this would be a behavior change.
- The original mutates \`o.shipping\` as a side effect. This is preserved explicitly.
- Shipping threshold uses \`>\` (strictly greater than 100), not \`>=\`. The original: \`if (t > 100)\` means exactly $100 still pays shipping. Preserved exactly.

### Verification Scenarios
- Empty order (0 items): Returns 0 -- Verified: YES
- Single item, non-VIP, total $50: Returns 60 (50 + 10 shipping) -- Verified: YES
- VIP customer, total $200: Returns 180 (200 * 0.9 = 180, free shipping) -- Verified: YES
- Exactly $100 non-VIP: Returns 110 (100 + 10 shipping, threshold is strictly >) -- Verified: YES

## Before/After Comparison

### Metrics
| Metric | Before | After | Change |
|--------|--------|-------|--------|
| Cyclomatic Complexity | 5 | 2 (main) + 1-2 (helpers) | Down 60% per function |
| Max Method Length | 16 lines | 7 lines | Down 56% |
| Code Smells | 4 | 0 | Down 100% |
| Magic Numbers | 4 | 0 | Down 100% |
| Number of Functions | 1 | 4 | Up 3 (intentional decomposition) |

### Key Improvements
- Business rules (discount rate, shipping threshold) now explicit and configurable via constants
- Main function reads as a high-level algorithm description
- Each helper function has a single testable responsibility
- Side effect (shipping mutation) is now clearly visible and commented

## Risk Assessment

### Overall Risk Level: LOW

### Risk Matrix
| Transformation | Risk | Probability | Blast Radius | Mitigation |
|---------------|------|-------------|--------------|------------|
| Rename Variable | LOW | Negligible | None | Mechanical transformation |
| Extract Constants | LOW | Negligible | None | Value-preserving extraction |
| Extract Method | LOW | Very low | Single function | Verify same inputs/outputs |
| Decompose Conditional | LOW | Low | Shipping logic | Test threshold boundary |

### Breaking Changes
None -- function signature and all observable behavior preserved exactly.

## Characterization Tests

\`\`\`javascript
describe('processOrder - behavioral equivalence', () => {
  test('returns 0 for empty order', () => {
    const order = { items: [], customer: { type: 'regular' } };
    expect(processOrder(order)).toBe(0);
  });

  test('calculates subtotal for single item', () => {
    const order = { items: [{ price: 50, qty: 1 }], customer: { type: 'regular' } };
    expect(processOrder(order)).toBe(60); // 50 + 10 shipping
  });

  test('calculates subtotal for multiple items', () => {
    const order = { items: [{ price: 30, qty: 2 }, { price: 20, qty: 1 }], customer: { type: 'regular' } };
    expect(processOrder(order)).toBe(90); // 80 + 10 shipping
  });

  test('applies VIP discount', () => {
    const order = { items: [{ price: 200, qty: 1 }], customer: { type: 'VIP' } };
    expect(processOrder(order)).toBe(180); // 200 * 0.9 = 180, free shipping
  });

  test('free shipping when total exceeds threshold', () => {
    const order = { items: [{ price: 150, qty: 1 }], customer: { type: 'regular' } };
    expect(processOrder(order)).toBe(150); // 150 + 0 shipping
  });

  test('charges shipping at exactly $100 (threshold is strictly greater)', () => {
    const order = { items: [{ price: 100, qty: 1 }], customer: { type: 'regular' } };
    expect(processOrder(order)).toBe(110); // 100 + 10 shipping
  });

  test('sets shipping as side effect on order object', () => {
    const order = { items: [{ price: 50, qty: 1 }], customer: { type: 'regular' } };
    processOrder(order);
    expect(order.shipping).toBe(10);
  });

  test('VIP with amount below free shipping threshold', () => {
    const order = { items: [{ price: 50, qty: 1 }], customer: { type: 'VIP' } };
    expect(processOrder(order)).toBe(55); // 50 * 0.9 = 45 + 10 shipping
  });
});
\`\`\`

## Migration Notes

Drop-in replacement -- no call site changes required. The three new helper functions (\`calculateSubtotal\`, \`applyCustomerDiscount\`, \`calculateShipping\`) are additions, not changes to existing API.
`}    </ExampleOutput>
  </Example>

  <Example>
    <ExampleInput>{`
class UserService:
    def get_user_data(self, user_id, db, cache, logger):
        logger.info(f"Getting user {user_id}")
        cached = cache.get(f"user:{user_id}")
        if cached:
            logger.info("Cache hit")
            return cached
        logger.info("Cache miss")
        user = db.query(f"SELECT * FROM users WHERE id = {user_id}")
        if user:
            user['full_name'] = user['first_name'] + ' ' + user['last_name']
            user['is_active'] = user['status'] == 'active'
            user['display_name'] = user['full_name'] if user['full_name'].strip() else user['email']
            cache.set(f"user:{user_id}", user, ttl=300)
            logger.info(f"Cached user {user_id}")
        return user
`}    </ExampleInput>
    <ExampleOutput>{`
## Summary

Refactored \`get_user_data\` to improve modularity by extracting data transformation into a pure function, reducing parameter count via dependency injection, and separating caching concerns. Applied Introduce Parameter Object, Extract Method, and Move Method techniques.

## Refactorability Assessment

**Verdict:** REFACTOR
**Rationale:** Single method with clear responsibilities that can be decomposed. The Long Parameter List and mixed abstraction levels are straightforward to address.

## Code Smells Identified

### High
- **Long Parameter List (Bloater)**: 4 parameters (user_id, db, cache, logger) passed to every call | \`line 2\` | Hard to call, hard to test, signals missing abstraction

### Medium
- **Feature Envy (Coupler)**: Method builds user display properties that belong on a User model | \`lines 9-11\` | Data transformation logic is in the wrong place
- **Mixed abstraction levels**: Cache management, database access, data transformation, and logging all in one method | \`lines 3-14\` | Violates Single Responsibility

### Low
- **SQL Injection risk** (noted but not fixed -- this is a bug, not a refactoring target): String interpolation in SQL query | \`line 8\` | Security vulnerability to address separately

## Public Interface Contract

**Functions/Methods:**
- \`UserService.get_user_data(self, user_id, db, cache, logger) -> dict | None\`: Fetches user by ID with cache-through pattern; enriches user dict with computed fields

**Side Effects:** Writes to cache on miss; writes log messages
**Error Conditions:** Returns None if user not found in database

[Abbreviated for example -- full output would continue with all sections]
`}    </ExampleOutput>
  </Example>

  <NegativeExample reason="Too vague -- no specific smells identified, no line numbers, no metrics, no behavioral verification">{`
    "The code has some quality issues. I cleaned it up by improving names and extracting methods. The new version is much cleaner and more maintainable."
`}  </NegativeExample>

  <NegativeExample reason="Changes behavior by adding a feature (tax calculation) instead of pure refactoring">{`
    "Refactored to add tax calculation. Added calculateTax() that applies 8% sales tax to the total. Also fixed the VIP discount to use strict equality."
`}  </NegativeExample>

  <NegativeExample reason="No behavioral equivalence verification, no risk assessment, no refactoring sequence">{`
    "Here's the refactored code: [code block]. It's better now because I used the Strategy pattern and split it into multiple classes with interfaces."
`}  </NegativeExample>
</Examples>

<If provider="anthropic">
  <Context type="domain" priority="helpful">
    Use structured analysis with clear section headings. When behavioral equivalence
    verification requires detailed reasoning, use step-by-step analysis to trace through
    each code path in both the original and refactored versions.
  </Context>
</If>

<If provider="openai">
  <Context type="domain" priority="helpful">
    Use markdown formatting consistently for readability. When presenting the refactoring
    sequence, use numbered steps with clear before/after code snippets for each transformation.
  </Context>
</If>

<If provider="google">
  <Context type="domain" priority="helpful">
    Structure the analysis in clearly delineated sections. Use tables for metrics comparison
    and code blocks with language annotations for all code examples.
  </Context>
</If>

<If provider="deepseek">
  <Context type="domain" priority="helpful">
    Provide thorough reasoning chains for each refactoring decision. Show complete code
    transformations with explicit before/after comparisons for each step.
  </Context>
</If>

<If provider={["mistral", "meta", "xai", "cohere"]}>
  <Context type="domain" priority="helpful">
    Use clear markdown structure with headings and code blocks. Present the analysis
    systematically following the template sections in order.
  </Context>
</If>

<Audience
  level="advanced"
  type="technical"
  knowledgeLevel="professional software developers familiar with refactoring concepts"
  goals={[
    "improve code quality without introducing defects",
    "reduce technical debt systematically",
    "learn which refactoring techniques to apply and when",
    "understand the risks and trade-offs of specific transformations"
  ]}
/>

<Tone type="professional" formality="semi-formal" energy="measured"
  avoidTones={["dismissive", "condescending"]} />

<Style type="technical" verbosity="moderate" />

<SuccessCriteria metrics={[
  { name: "Behavioral equivalence", threshold: "zero differences in observable behavior" },
  { name: "Smell resolution", threshold: "all critical and high severity smells addressed" },
  { name: "Metric degradation", threshold: "no quality metric worsened without justification" }
]}>
  <Criterion category="accuracy" weight="critical" metric="zero behavioral differences between original and refactored code">
    Refactored code preserves the exact observable behavior of the original for all inputs,
    including edge cases, error conditions, and side effects
  </Criterion>
  <Criterion category="accuracy" weight="critical" metric="public interface contract documented and unchanged">
    Public interface contract is explicitly documented and verified as unchanged
  </Criterion>
  <Criterion category="completeness" weight="critical" metric="all code smells identified with taxonomy name and location">
    All code smells are identified using standard taxonomy terminology with locations
  </Criterion>
  <Criterion category="accuracy" weight="critical" metric="100% of techniques use standard catalog names">
    Each refactoring technique is named correctly using standard catalog terminology
  </Criterion>
  <Criterion category="completeness" weight="important" metric="before/after metrics table with quantified changes">
    Before/after metrics are calculated accurately and presented in comparison format
  </Criterion>
  <Criterion category="clarity" weight="important" metric="every refactoring linked to a specific smell">
    Each refactoring decision is justified by connecting it to a specific identified smell
  </Criterion>
  <Criterion category="completeness" weight="important" metric="risk matrix covers all transformations">
    Risk assessment covers each transformation with probability, blast radius, and mitigation
  </Criterion>
  <Criterion category="completeness" weight="important">
    Behavioral equivalence verification section documents interface preservation and test scenarios
  </Criterion>
  <Criterion category="format" weight="important" metric="all template sections present">
    Output follows the specified markdown template structure completely
  </Criterion>
  <Criterion category="accuracy" weight="important" metric="zero degraded quality metrics or flagged with justification">
    No quality metric (complexity, coupling, cohesion) has degraded after refactoring;
    any metric that worsened is flagged with an explanation of why the trade-off is acceptable
  </Criterion>
</SuccessCriteria>

<References sources={[
  {
    title: "Refactoring: Improving the Design of Existing Code (2nd Edition)",
    url: "https://martinfowler.com/books/refactoring.html",
    description: "Martin Fowler's comprehensive catalog of refactoring techniques with mechanics and motivation"
  },
  {
    title: "Code Smells",
    url: "https://martinfowler.com/bliki/CodeSmell.html",
    description: "Surface indications that usually correspond to deeper problems in code"
  },
  {
    title: "Refactoring Techniques Catalog",
    url: "https://refactoring.guru/refactoring/techniques",
    description: "Visual catalog of refactoring patterns organized by category with examples"
  },
  {
    title: "Catalog of Refactorings",
    url: "https://refactoring.com/catalog/",
    description: "Official online companion to Fowler's Refactoring book with technique descriptions"
  },
  {
    title: "Refactoring vs Rewrite: How to Decide",
    url: "https://graphite.com/guides/refactor-vs-rewrite",
    description: "Guidelines for deciding between incremental refactoring and full rewrite"
  },
  {
    title: "Working Effectively with Legacy Code",
    url: "https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052",
    description: "Michael Feathers' techniques for safely refactoring legacy code: seams, characterization tests, sprout/wrap methods, and the legacy code change algorithm"
  },
  {
    title: "Refactoring to Patterns",
    url: "https://martinfowler.com/books/r2p.html",
    description: "Joshua Kerievsky's approach to evolving designs toward patterns through refactoring rather than imposing patterns upfront"
  },
  {
    title: "Strangler Fig Application",
    url: "https://martinfowler.com/bliki/StranglerFigApplication.html",
    description: "Martin Fowler's incremental migration pattern for gradually replacing legacy systems"
  },
  {
    title: "An Empirical Study of Refactoring Challenges and Benefits at Microsoft",
    url: "https://dl.acm.org/doi/abs/10.1109/TSE.2014.2318734",
    description: "Kim et al. (2014): Field study of 328 engineers on refactoring benefits (readability 43%, maintainability 30%) and risks in practice"
  }
]} />

<ChainOfThought style="structured" showReasoning />

<Context type="situational" label="Analysis Timestamp" priority="optional">
  Analysis performed: <DateTime format="YYYY-MM-DD HH:mm" />
</Context>

<PostExecution>
  <RunCommand command="echo 'Refactoring analysis complete. Review the output and run characterization tests before applying changes.'" />
</PostExecution>

</Prompt>
